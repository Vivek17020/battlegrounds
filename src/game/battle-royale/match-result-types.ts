// Match result payload types for MCP submission
// These types define what gets sent to the backend after each match

import { z } from 'zod';

// ─────────────────────────────────────────────
// ANTI-CHEAT SIGNALS
// ─────────────────────────────────────────────
export interface AntiCheatSignals {
  // Hash of aggregated player inputs during match
  inputHash: string;
  // Total game frames processed
  frameCount: number;
  // Average tick rate (should be ~60)
  avgTickRate: number;
  // Any detected anomalies
  suspiciousFlags: string[];
  // Input timing variance (low variance = bot-like)
  inputTimingVariance: number;
  // Movement pattern hash for replay verification
  movementHash: string;
}

// ─────────────────────────────────────────────
// MATCH RESULT PAYLOAD (Client → MCP)
// ─────────────────────────────────────────────
export interface MatchResultPayload {
  // Player's wallet address (must be verified via signature)
  walletAddress: string;
  // Unique match identifier (server-generated at match start)
  matchId: string;
  // Final placement (1st, 2nd, etc.)
  placement: number;
  // Total players in match (2, 3, or 5)
  playerCount: number;
  // Match duration in milliseconds
  durationMs: number;
  // Number of eliminations
  kills: number;
  // Anti-cheat telemetry
  antiCheat: AntiCheatSignals;
  // Unix timestamp when match ended
  timestamp: number;
  // Client-computed signature of payload
  clientSignature: string;
}

// ─────────────────────────────────────────────
// ZOD SCHEMA FOR VALIDATION
// ─────────────────────────────────────────────
export const AntiCheatSignalsSchema = z.object({
  inputHash: z.string().min(16).max(128),
  frameCount: z.number().int().min(100).max(100000),
  avgTickRate: z.number().min(30).max(120),
  suspiciousFlags: z.array(z.string().max(50)).max(20),
  inputTimingVariance: z.number().min(0).max(10000),
  movementHash: z.string().min(16).max(128),
});

export const MatchResultPayloadSchema = z.object({
  walletAddress: z.string().regex(/^0x[a-fA-F0-9]{40}$/, 'Invalid wallet address'),
  matchId: z.string().uuid('Invalid match ID format'),
  placement: z.number().int().min(1).max(5),
  playerCount: z.number().int().refine(v => [2, 3, 5].includes(v), {
    message: 'Player count must be 2, 3, or 5',
  }),
  durationMs: z.number().int().min(5000).max(300000),
  kills: z.number().int().min(0).max(4),
  antiCheat: AntiCheatSignalsSchema,
  timestamp: z.number().int().min(1700000000000), // After 2023
  clientSignature: z.string().min(32).max(256),
});

// ─────────────────────────────────────────────
// VALIDATION RESULT FROM MCP
// ─────────────────────────────────────────────
export interface MatchValidationResult {
  valid: boolean;
  matchId: string;
  placement: number;
  playerCount: number;
  // Validation checks performed
  checks: {
    walletVerified: boolean;
    matchSessionValid: boolean;
    durationWithinTolerance: boolean;
    antiCheatPassed: boolean;
    placementValid: boolean;
  };
  // Risk score 0-100 (higher = more suspicious)
  riskScore: number;
  // Rejection reason if invalid
  rejectionReason?: string;
  // Warnings that don't block validation
  warnings: string[];
}

// ─────────────────────────────────────────────
// TRUST MATRIX DOCUMENTATION
// ─────────────────────────────────────────────
/**
 * FIELD TRUST LEVELS:
 * 
 * TRUSTED (Server-generated, client cannot forge):
 * - matchId: Generated by MCP when match starts
 * - playerCount: Set by MCP at match registration
 * 
 * MUST VALIDATE (Client-reported, verify against server state):
 * - walletAddress: Require signed message proving ownership
 * - placement: Cross-check with match state, ensure ≤ playerCount
 * - durationMs: Compare against server match start time ± 5s tolerance
 * - kills: Ensure kills ≤ playerCount - 1
 * - timestamp: Compare with server clock ± 5s tolerance
 * 
 * USED FOR DETECTION (Client-computed, pattern analysis):
 * - antiCheat.inputHash: Compare patterns across matches
 * - antiCheat.frameCount: Flag if too low (speedhack) or impossibly high
 * - antiCheat.avgTickRate: Should be 55-65, flag outliers
 * - antiCheat.inputTimingVariance: Low variance = bot-like behavior
 * - antiCheat.movementHash: For replay verification if needed
 */

// ─────────────────────────────────────────────
// ANTI-CHEAT COLLECTOR (used in game client)
// ─────────────────────────────────────────────
export class AntiCheatCollector {
  private inputTimestamps: number[] = [];
  private frameTimestamps: number[] = [];
  private movementSamples: string[] = [];
  private suspiciousFlags: string[] = [];
  private frameCount: number = 0;
  
  recordInput(timestamp: number) {
    this.inputTimestamps.push(timestamp);
    // Keep last 1000 inputs
    if (this.inputTimestamps.length > 1000) {
      this.inputTimestamps.shift();
    }
  }
  
  recordFrame(timestamp: number) {
    this.frameTimestamps.push(timestamp);
    this.frameCount++;
    // Keep last 500 frame times
    if (this.frameTimestamps.length > 500) {
      this.frameTimestamps.shift();
    }
  }
  
  recordMovement(x: number, y: number) {
    // Sample every 10th position to reduce data
    if (this.movementSamples.length < 200) {
      this.movementSamples.push(`${Math.round(x)},${Math.round(y)}`);
    }
  }
  
  addSuspiciousFlag(flag: string) {
    if (this.suspiciousFlags.length < 20) {
      this.suspiciousFlags.push(flag);
    }
  }
  
  private simpleHash(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(16).padStart(8, '0');
  }
  
  private computeInputHash(): string {
    // Hash of input timing patterns
    const timingDeltas = this.inputTimestamps.slice(1).map((t, i) => t - this.inputTimestamps[i]);
    return this.simpleHash(timingDeltas.join(','));
  }
  
  private computeMovementHash(): string {
    return this.simpleHash(this.movementSamples.join('|'));
  }
  
  private computeInputTimingVariance(): number {
    if (this.inputTimestamps.length < 10) return 0;
    
    const deltas = this.inputTimestamps.slice(1).map((t, i) => t - this.inputTimestamps[i]);
    const mean = deltas.reduce((a, b) => a + b, 0) / deltas.length;
    const variance = deltas.reduce((sum, d) => sum + Math.pow(d - mean, 2), 0) / deltas.length;
    return Math.round(variance);
  }
  
  private computeAvgTickRate(): number {
    if (this.frameTimestamps.length < 10) return 60;
    
    const totalTime = this.frameTimestamps[this.frameTimestamps.length - 1] - this.frameTimestamps[0];
    const frames = this.frameTimestamps.length - 1;
    return totalTime > 0 ? Math.round((frames / totalTime) * 1000) : 60;
  }
  
  getSignals(): AntiCheatSignals {
    return {
      inputHash: this.computeInputHash(),
      frameCount: this.frameCount,
      avgTickRate: this.computeAvgTickRate(),
      suspiciousFlags: [...this.suspiciousFlags],
      inputTimingVariance: this.computeInputTimingVariance(),
      movementHash: this.computeMovementHash(),
    };
  }
  
  reset() {
    this.inputTimestamps = [];
    this.frameTimestamps = [];
    this.movementSamples = [];
    this.suspiciousFlags = [];
    this.frameCount = 0;
  }
}

// ─────────────────────────────────────────────
// CLIENT SIGNATURE HELPER
// ─────────────────────────────────────────────
export function computeClientSignature(payload: Omit<MatchResultPayload, 'clientSignature'>): string {
  // Simple deterministic signature of payload fields
  // In production, this would use a proper HMAC with a session key
  const data = [
    payload.walletAddress,
    payload.matchId,
    payload.placement,
    payload.playerCount,
    payload.durationMs,
    payload.kills,
    payload.timestamp,
    payload.antiCheat.inputHash,
    payload.antiCheat.frameCount,
  ].join('|');
  
  // Simple hash for now - in production use crypto
  let hash = 0;
  for (let i = 0; i < data.length; i++) {
    const char = data.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return Math.abs(hash).toString(16).padStart(16, '0') + Date.now().toString(16);
}
