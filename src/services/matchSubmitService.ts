// ============================================
// MCP Match Submit Service
// Client-side service with nonce generation
// ============================================

import { supabase } from '@/integrations/supabase/client';
import { 
  MatchResultPayload, 
  MatchValidationResult, 
  computeClientSignature 
} from '@/game/battle-royale/match-result-types';
import { MatchResult } from '@/game/battle-royale/types';

// Placeholder wallet address for demo (would come from real wallet connection)
const DEMO_WALLET_ADDRESS = '0x1234567890abcdef1234567890abcdef12345678';

export interface SubmitMatchResultOptions {
  result: MatchResult;
  walletAddress?: string;
}

export interface SubmitMatchResultResponse {
  success: boolean;
  validation?: MatchValidationResult & {
    calculatedReward?: number;
    rewardBreakdown?: {
      base: number;
      placement: number;
      kills: number;
      survival: number;
      penalties: number;
      final: number;
    };
  };
  error?: string;
  errorCode?: string;
  securityChecks?: {
    name: string;
    passed: boolean;
    details: string;
  }[];
}

// Generate a cryptographically secure nonce
function generateNonce(): string {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return Array.from(array)
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('');
}

export async function submitMatchResult(
  options: SubmitMatchResultOptions
): Promise<SubmitMatchResultResponse> {
  const { result, walletAddress = DEMO_WALLET_ADDRESS } = options;

  // Ensure we have the required data
  if (!result.matchId || !result.antiCheatSignals) {
    console.warn('[MatchSubmit] Missing matchId or antiCheatSignals, skipping submission');
    return { success: false, error: 'Missing required match data' };
  }

  try {
    // Generate unique nonce for replay prevention
    const nonce = generateNonce();

    // Build the payload
    const payloadWithoutSignature = {
      walletAddress,
      matchId: result.matchId,
      placement: result.placement,
      playerCount: result.playerCount || 2,
      durationMs: result.durationMs || Math.round(result.survivalTime * 1000),
      kills: result.kills,
      antiCheat: result.antiCheatSignals,
      timestamp: Date.now(),
      nonce,
    };

    // Compute client signature
    const clientSignature = computeClientSignature(payloadWithoutSignature);

    const payload: MatchResultPayload & { nonce: string } = {
      ...payloadWithoutSignature,
      clientSignature,
    };

    console.log('[MatchSubmit] Submitting match result:', {
      matchId: payload.matchId,
      placement: payload.placement,
      playerCount: payload.playerCount,
      nonce: nonce.substring(0, 8) + '...',
    });

    // Call the edge function
    const { data, error } = await supabase.functions.invoke('mcp-match-submit', {
      body: payload,
    });

    if (error) {
      console.error('[MatchSubmit] Edge function error:', error);
      return { success: false, error: error.message };
    }

    console.log('[MatchSubmit] Response:', data);

    if (data?.success && data?.data) {
      return {
        success: true,
        validation: data.data,
        securityChecks: data.data.securityChecks,
      };
    }

    return {
      success: false,
      error: data?.error || 'Unknown error',
      errorCode: data?.errorCode,
      securityChecks: data?.securityChecks,
    };

  } catch (err) {
    console.error('[MatchSubmit] Unexpected error:', err);
    return {
      success: false,
      error: err instanceof Error ? err.message : 'Unexpected error',
    };
  }
}

// ============================================
// Request Reward Grant (after match validation)
// ============================================

export interface RequestRewardOptions {
  matchId: string;
  walletAddress: string;
  rewardAmount: number;
  placement: number;
  playerCount: number;
}

export interface RequestRewardResponse {
  success: boolean;
  txHash?: string;
  blockNumber?: number;
  error?: string;
  errorCode?: string;
}

export async function requestRewardGrant(
  options: RequestRewardOptions
): Promise<RequestRewardResponse> {
  try {
    const nonce = generateNonce();
    const timestamp = Date.now();

    // Note: In production, the serverSignature would be generated by
    // a secure backend after validating the match. For demo purposes,
    // we're using a placeholder.
    const payload = {
      walletAddress: options.walletAddress,
      matchId: options.matchId,
      rewardAmount: options.rewardAmount,
      placement: options.placement,
      playerCount: options.playerCount,
      nonce,
      timestamp,
      serverSignature: 'demo_signature_' + nonce.substring(0, 16), // Placeholder
    };

    console.log('[RewardGrant] Requesting reward:', {
      matchId: options.matchId,
      wallet: options.walletAddress.substring(0, 10) + '...',
      amount: options.rewardAmount,
    });

    const { data, error } = await supabase.functions.invoke('mcp-reward-grant', {
      body: payload,
    });

    if (error) {
      console.error('[RewardGrant] Edge function error:', error);
      return { success: false, error: error.message };
    }

    if (data?.success && data?.data) {
      return {
        success: true,
        txHash: data.data.txHash,
        blockNumber: data.data.blockNumber,
      };
    }

    return {
      success: false,
      error: data?.error || 'Unknown error',
      errorCode: data?.errorCode,
    };

  } catch (err) {
    console.error('[RewardGrant] Unexpected error:', err);
    return {
      success: false,
      error: err instanceof Error ? err.message : 'Unexpected error',
    };
  }
}
